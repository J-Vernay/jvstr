/*
This is the C header for the StrView structure of the jvstr library, written by Julien Vernay ( jvernay.fr ) in 2021.
It contains both the API and the documentation.
jvstr is a library to manipulate strings in the C language.
The library is available under the Boost Software License 1.0, whose terms are below:

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef JVSTR_STRVIEW
#define JVSTR_STRVIEW

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <stdbool.h>
#include <string.h>



// Usage: `printf("my_strview = '" STRVIEW_FORMAT "'.\n", STRVIEW_ARGS(my_strview));`
#define STRVIEW_FORMAT "%.*s"
#define STRVIEW_ARGS(view) (int)view.size, view.begin

// Compile-time counterpart to StrView_make, when using literals.
// "sizeof(literal)-1" to remove '\0' at end of array
// STRVIEW_INIT is for initialization of global constants.
// STRVIEW_MAKE is for creating a temporary StrView, i.e. to be passed as argument/return value
#define STRVIEW_INIT(literal) { literal, sizeof(literal)-1 }
#define STRVIEW_MAKE(literal) (StrView) STRVIEW_INIT(literal)

// View of a contiguous sub string, which may be not null-terminated.
// The sub string is not mutable through the view.
// Precondition for functions taking StrView: `size == 0 || (begin != NULL)`
typedef struct StrView {
    char const* begin;
    size_t size;
    // Could have stored [ begin ; end ) instead of [ begin ; size ),
    //  but, (StrView){ "hello", sizeof("hello")-1 } works,
    // while (StrView){ "hello", "hello"+sizeof("hello")-1 } is not guaranteed to work.
    // which is useful for STRVIEW_MAKE.
} StrView;

// Construct StrView from null-terminated string.
// If construction from literal string, you may instead use STRVIEW_MAKE.
StrView StrView_make(char const* nt_str);

// Extract first char from the view.
char jvstr_extract_first(StrView* view);
// Extract last char from the view.
char jvstr_extract_last(StrView* view);

// Return first part and write second part in view.
// If `where + nb_discarded >= view.size`, a copy of initial view is returned, and `view` is made empty.
StrView jvstr_split(StrView* view, size_t where, size_t nb_discarded);

// Check if str starts with prefix.
bool jvstr_starts_with(StrView str, StrView prefix, size_t starting_pos);

// Check if str ends with suffix.
bool jvstr_ends_with(StrView str, StrView suffix);

// Check if two StrView's content are equals.
bool jvstr_equal(StrView a, StrView b);

// Compare two StrView lexicographically. Returns negative if a < b, positive if a > b, 0 if a == b.
int jvstr_compare(StrView a, StrView b);

// Find first occurrence of `ch`, str.size if not found.
size_t jvstr_find(StrView str, char ch);

// Find first occurrence of `ch` which is not preceded by `escaper`, str.size if not found.
size_t jvstr_find_unescaped(StrView str, char ch, char escaper);

// Find last occurrence of `ch`, -1 if not found.
size_t jvstr_rfind(StrView str, char ch);

// Number of consecutive chars starting at 'starting_pos' which are all in charset.
size_t jvstr_while_in(StrView str, StrView charset, size_t starting_pos);

// Number of consecutive chars starting at 'starting_pos' which are all NOT in charset.
size_t jvstr_until_in(StrView str, StrView charset, size_t starting_pos);

// Find first location of substr in str, str.size if not found.
size_t jvstr_search(StrView str, StrView substr);


#ifdef __cplusplus
}
#endif

#endif
