/*
This is the C implementation for the StrView structure of the jvstr library, written by Julien Vernay ( jvernay.fr ) in 2021.
It contains both the API and the documentation.
jvstr is a library to manipulate strings in the C language.
The library is available under the Boost Software License 1.0, whose terms are below:

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
#include "StrView.h"

#include <string.h>
#include <assert.h>

static size_t min_size(size_t a, size_t b) {
    return a < b ? a : b;
}


StrView StrView_make(char const* nt_str) {
    return (StrView){.begin = nt_str, .size = strlen(nt_str)};
}

char jvstr_extract_first(StrView* view) {
    --view->size;
    return *(view->begin++);
}

char jvstr_extract_last(StrView* view) {
    --view->size;
    return *(view->begin + view->size);
}


// Return first part and write second part in view.
StrView jvstr_split(StrView* view, size_t where, size_t nb_discarded) {
    nb_discarded = min_size(nb_discarded, view->size - where); // prevent overflow
    StrView retview = { .begin = view->begin, .size = where };
    view->begin += where + nb_discarded;
    view->size -= where + nb_discarded;
    return retview;
}



// Check if two StrView's content are equals.
bool jvstr_equal(StrView a, StrView b) {
    if (a.size != b.size) {
        return false;
    }
    return jvstr_compare(a, b) == 0;
}

// Compare two StrView lexicographically. Returns negative if a < b, positive if a > b, 0 if a == b.
int jvstr_compare(StrView a, StrView b) {
    size_t minsize = min_size(a.size, b.size);
    int result = memcmp(a.begin, b.begin, minsize);
    // comparing size. if a is empty: negative, if b is empty: positive, both: 0
    return result != 0 ? result : (int)(a.size - b.size);
}


// Check if str starts with prefix.
bool jvstr_starts_with(StrView str, StrView prefix, size_t starting_pos) {
    if (str.size < starting_pos + prefix.size) {
        return false;
    }
    return strncmp(str.begin + starting_pos, prefix.begin, prefix.size) == 0;
}

// Check if str ends with suffix.
bool jvstr_ends_with(StrView str, StrView suffix) {
    if (str.size < suffix.size) {
        return false;
    }
    return strncmp(str.begin + str.size - suffix.size, suffix.begin, suffix.size) == 0;
}

size_t jvstr_find(StrView str, char ch) {
    char const* ch_found = (char const*)memchr(str.begin, ch, str.size);
    return ch_found != NULL ? (size_t)(ch_found - str.begin) : str.size;
}

// Find first occurrence of `ch` which is not preceded by `escaper`
size_t jvstr_find_unescaped(StrView str, char ch, char escaper) {
    size_t ch_found = jvstr_find(str, ch);
    if (ch_found == 0) {
        return ch_found;
    }
    while (ch_found != str.size && str.begin[ch_found-1] == escaper) {
        ++ch_found;
        ch_found += jvstr_find((StrView){str.begin+ch_found,str.size-ch_found}, ch); 
    }
    return ch_found;
}

// Find last occurrence of `ch`, -1 if not found.
size_t jvstr_rfind(StrView str, char ch) {
    // Cannot use strrchr because not null-terminated, and memrchr does not exist.
    while (str.size > 0) {
        if (jvstr_extract_last(&str) == ch) {
            return str.size;
        }
    }
    return -1;
}

// Number of consecutive chars at beginning of str which are all in charset.
size_t jvstr_while_in(StrView str, StrView charset, size_t starting_pos) {
    char const* begin = str.begin;
    jvstr_split(&str, starting_pos, 0);
    while (str.size > 0) {
        char ch = jvstr_extract_first(&str);
        if (jvstr_find(charset, ch) == charset.size) { // if not found
            --str.begin; // correcting last extraction
            break;
        }
    }
    return str.begin - begin;
}

// Number of consecutive chars at beginning of str which are all NOT in charset.
size_t jvstr_until_in(StrView str, StrView charset, size_t starting_pos) {
    char const* begin = str.begin;
    jvstr_split(&str, starting_pos, 0);
    while (str.size > 0) {
        char ch = jvstr_extract_first(&str);
        if (jvstr_find(charset, ch) != charset.size) { // if found
            --str.begin; // correcting last extraction
            break;
        }
    }
    return str.begin - begin;
}

// Find first location of substr in str, str.size if not found.
size_t jvstr_search(StrView str, StrView substr) {
    if (substr.size == 0) {
        return 0;    
    }
    StrView original_str = str;
    char substr_first_char = jvstr_extract_first(&substr);
    while (true) {
        (void)jvstr_split(&str, jvstr_find(str, substr_first_char), 0);
        if (str.size == 0) {
            return original_str.size;
        }
        (void)jvstr_extract_first(&str);
        if (jvstr_starts_with(str, substr, 0)) {
            // Found, decrementing to get back first char
            return (str.begin-1) - original_str.begin;
        }
    }
}


